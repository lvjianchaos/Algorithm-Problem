> **比赛场次**：周赛147
> **比赛题目**： [3408. 设计任务管理器](https://leetcode.cn/problems/design-task-manager/) 

## 题意：

设计题，要求设计一个任务管理器，包含三个变量：userId, taskId, 任务的priority优先级。需要实现：任务的添加，修改，删除，执行优先级最高的任务。
具体如下：
1. 构造器`public TaskManager(List<List<Integer>> tasks)`
2. 添加函数`void add(int userId, int taskId, int priority)`
3. 修改`void edit(int taskId, int newPriority)` 
4. 删除`void rmv(int taskId)` 
5. 执行`int execTop()` 

## 题解：

#middle #懒删除堆 #堆 #优先队列 #priority_queue #设计 #哈希表 

由于要根据taskId修改优先级，且一个用户对应多个任务，故用哈希表记录每个任务编号对应的最新的优先级何用户编号。
由于要实现优先执行优先级最大、用户编号最大的任务，故要使用优先队列维护这三个变量
在进行构造器初始化操作时，循环遍历使用add()将要初始化的{userId,taskId.priority}加入哈希表和优先队列中。
add()函数，map.put()与pq.offer()存入数据
edit()函数，注意懒修改，从map根据taskId获取userId直接添加add()
rmv()函数，懒删除，将这个taskId对应的priority设置为-1
execTop()函数，不断从pq中取出数据，判断所取数据是否是对的

### 代码实现
```java
class TaskManager {
	// taskId -> [priority,userId]
    private final Map<Integer,int[]> mp = new HashMap<>();
	// [taskId,priority,userId]
	// 编写排序规则
    private final PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] != b[0] ? b[0] - a[0] : b[1] - a[1]);

    public TaskManager(List<List<Integer>> tasks) {
        for(List<Integer> task : tasks) {
            add(task.get(0),task.get(1),task.get(2));
        }
    }
    
    public void add(int userId, int taskId, int priority) {
        mp.put(taskId,new int[]{priority, userId});
        pq.offer(new int[]{priority,taskId,userId});
    }
    
    public void edit(int taskId, int newPriority) {
        int userId = mp.get(taskId)[1];
        add(userId,taskId,newPriority);
    }
    
    public void rmv(int taskId) {
        mp.get(taskId)[0] = -1;
    }
    
    public int execTop() {
        while(!pq.isEmpty()) {
            int[] top = pq.poll();
            int priority = top[0], taskId = top[1],userId = top[2];
            int[] p = mp.get(taskId);
            if(p[0] == priority && p[1] == userId) {
                rmv(taskId);
                return userId;
            }
        }
        return -1;
    }
}

/**
 * Your TaskManager object will be instantiated and called as such:
 * TaskManager obj = new TaskManager(tasks);
 * obj.add(userId,taskId,priority);
 * obj.edit(taskId,newPriority);
 * obj.rmv(taskId);
 * int param_4 = obj.execTop();
 */
```
> **时间复杂度：**
> - $O(nlogn)$ 初始化
> - add 和 edit：$O(log(n+q))$，其中 q 是 add 和 edit 的调用次数之和。
> - rmv：$O(1)$。
> - execTop：均摊 $O(log(n+q))$。每个元素至多入堆出堆各一次。
> **空间复杂度：**$O(n+q)$ 

## 其他
