**比赛场次** “金山-讯飞”杯2024年武汉理工大学程序设计竞赛

**比赛题目** B-补码转换

<!--more-->

1 seconds / 256 megabytes

standard input / standard output

## 题目

已知某整数 x∈[−231,231−1]。现做如下定义：

 （1）该数的原码为：在第 32 位写上其符号，0 表示正数，1 表示负数;在后面的 31 位中写下其绝对值的二进制表示，不足 31 位的向高位补 0，得到的 32 位二进制数。

 （2）若该数为正数，则其反码为其原码本身；若该数为负数，则其反码为其原码除符号位之外每一位都取反得到的结果。

 （3）若该数为正数，则其补码为其原码本身；若该数为负数，则其补码为其反码 +1 得到的结果。

 例如：对于 −195 ，其：

 （1）原码为 10000000000000000000000011000011，

 （2）反码为 11111111111111111111111100111100，

 （3）补码为 11111111111111111111111100111101。

 特别地，0 的原码表示有 +0 和 −0 两种，但是其补码表示是唯一的。

 现给定一整数的 32 位原码，请你计算其补码。

## 输入

一长度为 32 的二进制数，表示该数的原码。

## 输出

一长度为 32 的二进制数，表示该数的补码。

## 样例

**输入**

> 10000000000000000000000011000011

**输出**

> 11111111111111111111111100111101

**输入**

> 10000000000000000000000000000000

**输出**

> 00000000000000000000000000000000

## 解释

样例二中的输入为 −0 的原码。

## 题解

对于补码的认识。

#### 官方题解

可以使用一个数组对输入的原码进行存储。 然后将之后每位都和最高位异或，最后将末尾加一，依次处理进位，将答案输出。

## 代码

##### **赛时代码**

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    string s;cin >> s;
    // 特殊情况
    if(s == "10000000000000000000000000000000") s[0] = '0';
    // 关于原码变补码：从后往前找取第一个‘1’，这个‘1’之前的所有数值位取反（不包含这个‘1’）
    if(s[0] == '1')
        for(int i = 1;i < s.rfind('1');i ++)
            s[i] = ((s[i] == '1') ? '0' : '1');
    
    cout << s << '\n';
    return 0;
}
```

