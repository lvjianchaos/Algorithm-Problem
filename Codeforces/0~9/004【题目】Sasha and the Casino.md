**CF Round 926(Div. 2)**

**[C. Sasha and the Casino][https://codeforces.com/contest/1929/problem/C ]** 

<!--more-->

1 seconds / 256 megabytes

standard input / standard output

## 题目

萨沙决定把最好的手提包送给他的女朋友，但不幸的是，这个手提包非常昂贵。因此，萨沙想赚取它。在网上查看了赚钱技巧后，他决定去赌场。

萨沙知道赌场的运作规则如下。如果萨沙下注 y 个金币(其中 y 为正整数)，如果赢了，他将获得 y⋅k 个金币(即他的金币数量将增加 y⋅(k−1)。如果输了，他将输掉全部投注金额(即他的硬币数量将减少 y )。

请注意，投注金额必须始终是一个正整数( >0 )，并且不能超过萨沙当前的金币数量。

萨沙还知道赌场有一个促销活动：他不能连续输超过 x次。

最初，萨沙有 a个金币。他想知道自己是否可以下注保证赢取任意数量的硬币。换句话说，对于任意整数 n，萨沙是否真的可以下注，使得任何不违背上述规则的结果，在某个时刻他都至少有 n枚硬币。

## 输入

每个测试由多个测试用例组成。第一行包含一个整数 t( 1≤t≤1000 )--测试用例数。( 1≤t≤1000 )--测试用例的数量。测试用例说明如下。

每个测试用例的单行包含三个整数 k,x和 a( 2≤k≤30, 1≤x≤100 , 1≤a≤1e9 )--赢钱时的加注次数、连续输钱的最大次数以及萨沙拥有的初始硬币数。

## 输出

对于每个测试用例，如果萨沙可以实现，则输出 "YES"(不带引号)，否则输出 "NO"(不带引号)。

您可以在任何情况下输出 "YES "和 "NO"(例如，字符串 "yEs"、"yes "和 "Yes "将被识别为肯定答案)。

## 样例

**输入**

> 9
> 2 1 7
> 2 1 1
> 2 3 15
> 3 3 6
> 4 4 5
> 5 4 7
> 4 88 1000000000
> 25 69 231
> 13 97 18806

**输出**

> YES
> NO
> YES
> NO
> NO
> YES
> NO
> NO
> NO

## 解释

在第一个测试案例中，萨沙可以按以下步骤进行：

- 如果萨沙第一次下注或之前赢了，那么他下注 $1$ 个硬币。
- 如果萨沙输掉了之前的赌注，那么他将投入 $2$ 枚硬币。

注意，萨沙不能连续输超过一次。

可以证明，使用这种策略，萨沙可以获得他想要的任意数量的硬币。

在第二个测试案例中，萨沙第一次只能下注 1 枚硬币。但如果输了，他就不能再下注，所以他不能保证得到他想要的所有硬币。

## 题解

**题意**

赌博。初始钱a 最多会输x次 会有大保底让你**在x + 1次必赢**。

输了，投的钱没有；

赢了，可获得k倍钱(即增加了k-1倍投入钱且投入钱返回) 

判断是否可以赚到**任意钱**。

**思路**

##### 【**博弈论 思维**】

看作是和赌场老板的**博弈**，并且我们都知道大保底这件事，这是共识。

在投钱x次的过程中，我们一定要让他不让我们赢，因为如果在输x次中赢了一次，那么将重新开始，如果这是输钱的操作那么我们永不可能赢(这肯定是输钱的，因为如果我们赢钱，老板一定不会让我们赢)。

所以我们要投的钱，一定是：如果我们赢了 并可以 追平失去的钱且+1，这样的话老板一定不会让我们赢。如果没有这么多钱来投入 **保证** 如果赢了可以赚钱的操作，那么老板一定让我们赢，这是一次输钱操作，然后又会回到当初，我们不会赢。如果我们成功连续输掉x次，在第x+1次，我们必赢，所以一定会全盘投入，如果这次赚到钱不如起始钱，那么我们不可能赢，反之即赢。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
// 博弈论
using ll = long long;
const int maxn = 2e6 + 5;

void solve() {
    ll k, x, a;
    cin >> k >> x >> a;
    ll temp = a; // 临时变量
    ll sum = 0; // 之前已经输的钱
    ll now = 0; // 此次要投的钱
    for (int i = 1; i <= x + 1; i++) // 为什么k+1（下有）
    {
        if (i == x + 1) now = a; // k+1的原因
        else now = sum / (k - 1)+ 1; // 每次投钱要保证 之前投的钱 要小于 这次获胜能赚到的钱
        // 推导：
        // sum + now < k * now
        // now * (k - 1) > sum
        // now > sum / (k - 1)
        // => now = sum / (k - 1) + 1;
        // 如果掏不出这么多钱 就输了
        a -= now;
        if (a < 0) {
            cout << "No\n";
            return ;
        }
        sum += now;
//        cout << a << endl;
    }
    a += now * k;
    if (a <= temp) cout << "No\n"; // 最后的钱<=原来的钱
    else cout << "Yes\n";
    return ;
}

int main() {
    ios::sync_with_stdio(0);
    int T;
    cin >> T;
    while (T--) solve();
}
```