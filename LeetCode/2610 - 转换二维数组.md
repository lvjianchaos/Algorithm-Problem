## 题意
给你一个数组 $nums$，要求你将其变为二维数组，满足以下条件：
- 二维数组中的每行无重复数字
- 二维数组只且仅只包含 $nums$ 中的元素
- 要尽可能减少二维数组的行数
注意：二维数组每行的元素个数不一定相同

## 题解
#middle #哈希表 #迭代器 #贪心

贪心的思考，尽可能的在一行中添加尽可能多的元素，所以行数就是$max(相同元素的个数数组)$，关键在于如何使每行元素各不相同。我们需要进行元素个数的维护来确定***行***。
先使用*哈希表*维护元素个数，再进行二维数组的构建；构建过程是：循环遍历哈希表，完成每一行的构建，注意删除操作，这其中可能运用到迭代器。

当然构建过程，可以**边循环便构建**，也就是说：在遍历过程中统计这个数的出现次数，根据出现次数在对应行进行元素的添加。
<img src="https://pic.leetcode.cn/1741320320-YkycVn-lc2610-c.png" width="60%" />
#### 学习
##### java中HashMap的API
1. **`put(Key key, Value value)`：放入键值对**
	1. 如果HashMap中已经存在相同的Key，则新的Value会覆盖旧的Value。
2. **`get(Key key)`：获取Value**
	1. 如果HashMap中不存在该Key，则返回`null`。
3. **`remove(Key key)`：移除键值对**
4. **`containsKey(Key key)`：判断Key是否存在**
5. **`containsValue(Value value)`：判断Value是否存在**
	1.  这个方法的效率相对较低，因为它需要遍历整个HashMap；通常不推荐频繁使用。
6. **`size()`：获取键值对数量**
7. **`isEmpty()`：判断是否为空**
8. **`clear()`：清空HashMap**
9. **`keySet()`：获取所有Key的集合**
	1.  返回一个包含HashMap中所有Key的Set集合。
10. **`values()`：获取所有Value的集合**
	1. 返回一个包含HashMap中所有Value的Collection集合。
11. **`entrySet()`：获取所有键值对的集合**
	1. 返回一个包含HashMap中所有键值对的Set集合，每个元素是一个`Map.Entry`对象。`Map.Entry`对象包含了Key和Value。
	2. **这是遍历HashMap最高效的方式**
12. ***merge()*** **智能合并器**
	`merge(Key key, Value value, BiFunction<? super Value, ? super Value, ? extends Value> remappingFunction)`
	
	- **`key`：** 要合并的键。
	- **`value`：** 要合并的值。
	- **`remappingFunction`：** 一个函数式接口，用于处理键冲突。它接收两个参数：
	    - `oldValue`：HashMap中已存在的键对应的值。
	    - `value`：要合并的值。
	    - `remappingFunction`返回的值将作为合并后键对应的新值。
	
	**`merge()`方法的工作流程：**
	
	1. **检查键是否存在：** `merge()`方法首先检查HashMap中是否已经存在指定的键。
	2. **键不存在：** 如果键不存在，则将键值对直接添加到HashMap中。
	3. **键存在：** 如果键存在，则调用`remappingFunction`来处理键冲突。
	4. **`remappingFunction`返回`null`：** 如果`remappingFunction`返回`null`，则从HashMap中移除该键。
	5. **`remappingFunction`返回非`null`值：** 如果`remappingFunction`返回非`null`值，则将HashMap中该键对应的值更新为`remappingFunction`返回的值。
##### java中ArrayList的API
1. **`add(E e)`：添加元素到末尾**
2. **`add(int index, E e)`：在指定位置插入元素**
3. **`get(int index)`：获取指定位置的元素**
4. **`set(int index, E e)`：修改指定位置的元素**
5. **`remove(int index)`：移除指定位置的元素**
6. **`remove(Object o)`：移除指定的元素**
7. **`size()`：获取元素数量**
8. **`isEmpty()`：判断是否为空**
9. **`clear()`：清空ArrayList**
10. **`contains(Object o)`：判断是否包含指定元素**
11. **`indexOf(Object o)`：查找指定元素的索引**
	1. 返回ArrayList中第一个与指定元素相等的元素的索引。如果ArrayList中不包含该元素，则返回-1。
12. **`lastIndexOf(Object o)`：查找指定元素的最后一个索引**
	1. 如果ArrayList中不包含该元素，则返回-1。
	2. （当列表中可能存在重复元素时有用）
13. **`toArray()`：转换为数组**
	1. 将ArrayList转换为一个Object数组。
14. **`toArray(T[] a)`：转换为指定类型的数组**
15. **`subList(int fromIndex, int toIndex)`：获取子列表**
	1. 不包含`toIndex`位置的元素


##### 关于java迭代器
1. **`hasNext()`：判断是否还有下一个元素**
    - **作用：** 如果迭代器指向的集合中还有下一个元素，则返回`true`；否则，返回`false`。
    - **应用场景：** 在遍历集合之前，可以使用`hasNext()`方法来判断是否还有元素可以遍历。
2. **`next()`：获取下一个元素**
    - **作用：** 返回迭代器指向的集合中的下一个元素，并将迭代器指向下一个元素。
    - **应用场景：** 在`hasNext()`方法返回`true`之后，可以使用`next()`方法来获取下一个元素。
    - **注意：** 如果`hasNext()`方法返回`false`，而你仍然调用`next()`方法，则会抛出`java.util.NoSuchElementException`异常。
3. **`remove()`：移除当前元素**
    - **作用：** 移除迭代器指向的集合中当前元素。
    - **应用场景：** 在遍历集合的过程中，如果需要删除某些元素，可以使用`remove()`方法。
    - **注意：**
        - `remove()`方法只能在调用`next()`方法之后调用，并且只能调用一次。
        - 如果在调用`next()`方法之前调用`remove()`方法，或者在调用`remove()`方法之后再次调用`remove()`方法，则会抛出`java.lang.IllegalStateException`异常。
- **Java中迭代器的`remove()`方法行为：**
	1. **调用`next()`方法：** 必须先调用`next()`方法，才能调用`remove()`方法。`remove()`方法删除的是`next()`方法上次返回的元素。
	2. **删除当前元素：** `remove()`方法会删除迭代器当前指向的元素。
	3. **迭代器状态更新：** `remove()`方法会自动更新迭代器的状态，以便下次调用`next()`方法时，迭代器能够正确地指向下一个元素。

##### 关于CPP迭代器
- **`erase(it)`：** 当你使用`erase(it)`删除迭代器`it`指向的元素时，`it`本身会失效。但是，`erase()`方法会返回一个指向被删除元素之后元素的有效迭代器。
### Java在创建列表的构造函数
```java
class Solution {
        public List<List<Integer>> findMatrix(int[] nums) {
        // 统计每个元素的出现次数
        Map<Integer, Integer> cnt = new HashMap<>();
        for (int x : nums) 
            cnt.merge(x, 1, Integer::sum); // cnt[x]++

        List<List<Integer>> ans = new ArrayList<>();
        while (!cnt.isEmpty()) { // 还有剩余元素
            List<Integer> row = new ArrayList<>(cnt.keySet());
            ans.add(row);

            // cnt 中的每个元素的出现次数都减一
            for (Integer x : row) {
                int c = cnt.get(x) - 1;
                if (c == 0) cnt.remove(x); // 去掉出现次数为 0 的元素
                else cnt.put(x, c); // 更新出现次数
            }
        }
        return ans;
    }
}
```
### 写法II - 迭代器
```java
class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
        // 统计每个元素的出现次数
        Map<Integer, Integer> cnt = new HashMap<>();
        for (int x : nums) {
            cnt.merge(x, 1, Integer::sum); // cnt[x]++
        }

        List<List<Integer>> ans = new ArrayList<>();
        while (!cnt.isEmpty()) { // 还有剩余元素
            List<Integer> row = new ArrayList<>(cnt.size()); // 预分配空间
            // 一边遍历哈希表，一边删除元素
            Iterator<Map.Entry<Integer, Integer>> it = cnt.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry<Integer, Integer> e = it.next();
                row.add(e.getKey());
                int c = e.getValue() - 1; // 出现次数减一
                if (c == 0) {
                    it.remove(); // 去掉出现次数为 0 的元素
                } else {
                    e.setValue(c); // 更新出现次数
                }
            }
            ans.add(row);
        }
        return ans;
    }
}
```
```cpp
class Solution {
public:
    vector<vector<int>> findMatrix(vector<int>& nums) {
        // 统计每个元素的出现次数
        unordered_map<int, int> cnt;
        for (int x : nums) {
            cnt[x]++;
        }
  
        vector<vector<int>> ans;
        while (!cnt.empty()) {
            vector<int> row;
            // cnt 中的每个元素的出现次数都减一
            // 一边遍历哈希表，一边删除元素
            for (auto it = cnt.begin(); it != cnt.end();) {
                row.push_back(it->first);
                if (--it->second == 0) {
                    it = cnt.erase(it);
                } else {
                    it++;
                }
            }
            ans.push_back(row);
        }
        return ans;
    }
};
```
### 边循环边创建
```java
class Solution {
    public List<List<Integer>> findMatrix(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Map<Integer,Integer> cnts = new HashMap<>();
  
        for(int num : nums) {
            int idx = cnts.getOrDefault(num,0);
            cnts.put(num,idx+1);
            if(res.size() <= idx) {
                res.add(new ArrayList<>());
            }
            res.get(idx).add(num);
        }
        return res;
    }
}
```