> **比赛场次**：周赛283
> **比赛题目**： Q4 [2197. 替换数组中的非互质数](https://leetcode.cn/problems/replace-non-coprime-numbers-in-array/) 
## 题意：
给一整型数组，若邻项 $a,b$ 是非互质数，你需要消除邻项两元素并替换为 $lcm(a,b)$ 。注意：你需要重复该过程直至无法进行消除替换操作。
补充：$GCD(x, y) > 1$ ，则 二者为非互质数。
## 题解：
#数学 #栈 #gcd #lcm #math #数论 #hard

可以证明任意顺序进行邻项非互质数的替换操作最终得到结果相同：$lcm(a,b,c) = lcm(lcm(a,b),c) = lcm(a,lcm(b,c))$ 。
故而为方便编码，我们约定从左边开始进行消除替换操作。
按照题意，我们模拟该操作过程：
输入：\[6, 4, 3, 2, 7, 6, 2\]
	6
	6 4 > 12
	12 3 > 12
	12 2 > 12
	12 7
	12 7 6
	12 7 6 2 > 12 7 6
	12 7 6 = $ans$ 
对于这样依据某个条件持续删除替换元素，我们很容易想到括号匹配问题，不过那里并未进行替换。这类**邻项消除**的通用做法就是**使用栈进行模拟**。显而易见，我们上述的模拟过程就是不断入栈出栈的过程。
故此题解法就是：
1. 从左到右遍历数组
2. 对每个元素$a$，若栈不为空且且栈顶与其不互质，则弹出栈顶$y$，并令$a = lcm(a,b)$，循环直到栈空或互质
3. 入栈 $a$
4. 遍历结束，该栈就是答案

当然除此之外，就还需要掌握$gcd$与$lcm$的写法...... => 一般为**辗转相除法**实现
### 代码实现
虽然$java.util$中有$Stack$的实现，但通常推荐使用自定义栈或使用 `Deque` 接口的实现（如 `ArrayDeque` ）来模拟栈的行为。原因在于：[为什么Java已经不推荐使用Stack了？](https://jishuzhan.net/article/1942470823457107970)
但由于本题，返回值为$List<Integer>$，故而使用$ArrayList$实现模拟栈。
```java
class Solution {
    private int gcd(int a,int b) {
        return b == 0 ? a : gcd(b,a%b);
    }

    private int lcm(int a,int b) {
	    // 先除再乘，防止溢出
        return a / gcd(a,b) * b;
    }

    public List<Integer> replaceNonCoprimes(int[] nums) {
        List<Integer> stk = new ArrayList<>();
        for(int num : nums) {
            while(!stk.isEmpty() && gcd(num,stk.getLast()) > 1) {
                num = lcm(num,stk.removeLast());
            }
            stk.add(num);
        }
        return stk;
    }
}
```
> **时间复杂度：**$O(nlogM)$ （n为数组长度，M为数组元素最大值）
> **空间复杂度：**$O(n)$ 
## 其他
此题应该不太能达到 $@leetcode$ #hard 的水平，私以为若把 ”可以证明的是，以 **任意** 顺序替换相邻的非互质数都可以得到相同的结果。“ 这句提示去除或许可上 #hard 。

关于`ArrayList`能使用`removeLast()`、`getLast()`等方法，是因为 Java 新版本在`List`接口中添加了这些方法的默认实现。而`LinkedList`作为`Deque`的实现类，原本就有这些方法，并且会提供更适配其数据结构的高效实现。