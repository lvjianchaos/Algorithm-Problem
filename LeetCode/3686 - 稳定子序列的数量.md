> **比赛场次**：周赛467
> **比赛题目**： Q4 [3686. 稳定子序列的数量](https://leetcode.cn/problems/number-of-stable-subsequences/)

## 题意：
给定整型数组，要求你求出稳定子序列的数量。
当子序列中不存在**连续3个元素奇偶性相同**，则称该子序列稳定。
注意：答案可能极大，故要将答案对 $10^9 + 7$ 取余数后返回
## 题解：

#dp #子序列 #hard 

在构建子序列的过程中，子序列的种类只会出现4种：
$①$连续2个偶结尾、$②$连续1个偶结尾
$③$连续2个奇结尾、$④$连续1个奇结尾
遍历数组，若当前元素为偶数，那么可以将这个元素加在3,4后或单独成子序列转换为连续1个偶结尾的子序列，还可以加在2后转换为连续2个偶结尾的子序列。当元素为奇数时同理。

举例：\[4, 19, 9, 13\]
1. even1 = 1 ( 4 ), even2 = 0, odd1 = 0,odd2 = 0 
2. even1 = 1 ( 4 ), even2 = 0, odd1 = 2( 4,19  19 ), odd2 = 0
3. even1 = 1 ( 4 ), even2 = 0, odd1 = 4( 4,19  19  4,9  9), odd2 = 2( 4,19,9  19,9 )
4. even1 = 1 ( 4 ), even2 = 0, odd1 = 6( 4,19  19  4,9  9  4,13  13 ), odd2 = 6( 4,19,9  19,9  4,19,13  19,13  4,9,13  9,13 )

ans = 1+0+6+6 = 13 
需要注意在过程中防止整数溢出，进行取模。

### 代码实现
```java
class Solution {
    private final int MOD = 1000000007;

    public int countStableSubsequences(int[] nums) {
        long even1 = 0; // 结尾为连续1个偶数的子序列的个数
        long even2 = 0; // 结尾为连续1个偶数的子序列的个数
        long odd1 = 0; // 结尾为连续1个奇数的子序列的个数
        long odd2 = 0; // 结尾为连续2个奇数的子序列的个数
        
        for (int num : nums) {
            if (num % 2 == 0) {
                long newEven1 = (odd1 + odd2 + 1) % MOD;
                long newEven2 = even1 % MOD;
                even1 = (even1 + newEven1) % MOD;
                even2 = (even2 + newEven2) % MOD;
            } else {
                long newOdd1 = (even1 + even2 + 1) % MOD;
                long newOdd2 = odd1 % MOD;
                odd1 = (odd1 + newOdd1) % MOD;
                odd2 = (odd2 + newOdd2) % MOD;
            }
        }
        return (int)((even1 + even2 + odd1 + odd2) % MOD);
    }
}
```

> **时间复杂度：**$O(n)$
> **空间复杂度：**$O(1)$ 

```java
class Solution {
    public int countStableSubsequences(int[] nums) {
        final int MOD = 1_000_000_007;
        long[][] f = new long[2][2];
        for (int x : nums) {
            x %= 2;
            f[x][1] = (f[x][1] + f[x][0]) % MOD;
            f[x][0] = (f[x][0] + f[x ^ 1][0] + f[x ^ 1][1] + 1) % MOD;
        }
        return (int) ((f[0][0] + f[0][1] + f[1][0] + f[1][1]) % MOD);
    }
}
```
> **时间复杂度**：$O(nk)$，其中 $n$ 是 $nums$ 的长度，$k=2$ 表示最多 $k$ 个连续元素的奇偶性相同。
> **空间复杂度**：$O(k)$
## 其他
我其实一开始思考的是排列组合、快速幂等数学问题，后发现无法减去所有情况且复杂度仍很高，故放弃。

子序列问题具有较强的子问题特性，因而常用 #dp 进行解决。