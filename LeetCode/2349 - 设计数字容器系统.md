> **比赛场次**：周赛83
> **比赛题目**： Q3 [2349. 设计数字容器系统](https://leetcode.cn/problems/design-a-number-container-system/) 

## 题意：

你要设计一个类，满足以下功能：
- `NumberContainers()` 初始化数字容器系统。
- `void change(int index, int number)` 在下标 `index` 处填入 `number` 。如果该下标 `index` 处已经有数字了，那么用 `number` 替换该数字。
- `int find(int number)` 返回给定数字 `number` 在系统中的最小下标。如果系统中没有 `number` ，那么返回 `-1`

## 题解：

#middle  #哈希表 #hashmap #堆 #懒删除堆 #优先队列 #有序集合 #set #priority_queue #设计

可以知道，我们这个类维护了数字和下标之间的关系，关系如下：
1. 一个下标对映一个数字
2. 一个数字对映多个下标
对于这样的映射关系，考虑数据结构 #hashmap 。
我们维护关系 $1.$ 显然`key`与`value`都是`Integer`；维护关系 $2.$ `key`即是数字，值为另一个存储多个下标的数据结构，为了方便读取最小值，我们想到数据结构 #set 有序集合来存储，当然也可以是 #优先队列 进行维护最小值。这两种方式各有优劣，在 [[#其他]] 我们会讨论。
#### 对于 #有序集合
关于`change`，我们每次插入或修改`index`位置的`number`时，若是修改，则原来的`number`映射的`index`则需删除，然后更新
#### 对于 #优先队列 
我们采取一种**懒删除**的策略
关于`change`，不删除旧数据，直接更新
关于`find`，查看堆顶元素的下标对应的`number`是否与现在的相同，若不同则说明那是旧数据，弹出即可，反之就是答案。

### 代码实现
```java
// 法一：哈希 + 有序集合
class NumberContainers {
    private final Map<Integer,Integer> indexToNumber = new HashMap<>();
    private final Map<Integer,TreeSet<Integer>> numberToIndices = new HashMap<>();


    public void change(int index, int number) {
	    // 删除旧数据
        Integer oldNumber = indexToNumber.get(index);
        if(oldNumber != null) {
            numberToIndices.get(oldNumber).remove(index);
        }
		// 更新
        indexToNumber.put(index,number);
        numberToIndices.computeIfAbsent(number, _ -> new TreeSet<>()).add(index);
    }

    public int find(int number) {
        TreeSet<Integer> indices = numberToIndices.get(number);
        return indices == null || indices.isEmpty() ? -1 : indices.first();
    }

}
```

> **时间复杂度：**
> 	- 初始化 $O(1)$。
> 	- change：$O(log\ q)$，其中 $q$ 是 $change$ 的调用次数。
> 	- find：$O(log\ q)$ 或者 $O(1)$，取决于有序集合是否额外维护最小值。
> **空间复杂度：**$O(q)$ 

---
```java
// 法二：哈希 + 懒删除堆
class NumberContainers {
    private final Map<Integer, Integer> indexToNumber = new HashMap<>();
    private final Map<Integer, PriorityQueue<Integer>> numberToIndices = new HashMap<>();

    public void change(int index, int number) {
        // 添加新数据
        indexToNumber.put(index, number);
        numberToIndices.computeIfAbsent(number, _ -> new PriorityQueue<>()).offer(index);
    }

    public int find(int number) {
        PriorityQueue<Integer> indices = numberToIndices.get(number);
        if (indices == null) {
            return -1;
        }
        while (!indices.isEmpty() && indexToNumber.get(indices.peek()) != number) {
            indices.poll(); // 堆顶货不对板，说明是旧数据，删除
        }
        return indices.isEmpty() ? -1 : indices.peek();
    }
}
```

> **时间复杂度：**
> 	- 初始化 $O(1)$。
> 	- change：$O(log\ q)$，其中 $q$ 是 $change$ 的调用次数。
> 	- find：均摊 $O(log\ q)$ 。
> **空间复杂度：**$O(q)$ 

## 其他
#### 懒删除堆
这种 **“堆+延迟删除”** 的策略效率的高效只存在于特定的场景中。
因为将删除操作都丢给了`find`，写操作的速度会比有序集合（还要找旧数据、删旧索引等）要轻快。
但正如上述麻烦全都丢给了读操作，每次查都可能要先清除一堆旧数据，且不查的话，旧数据就会一直占据内存，越堆越多，反而单词查询比一般的`set`慢很多。
所以它的高效在于：“写多查少”，故而我们可以认为`set`这样的会更稳定。

---
#### 优化法一
此外对于法一可优化的点：
- 在`change`中，若存在旧数据，我们可以先判定旧和新数据是否相等，若相等就可跳过后续步骤。

---
#### 关于 ***computeIfAbsent()*** 方法  
在 Java 中，`computeIfAbsent()`方法源自 `java.util.Map` 接口 ，是 Java 8 引入的默认方法（default method），因此所有实现了 `Map` 接口的类（如`HashMap`、`TreeMap`、`ConcurrentHashMap`等）都可以使用该方法。

`computeIfAbsent()`的核心作用是：**当 Map 中指定的键（key）不存在或对应的值为`null`时，通过传入的函数计算一个值，并将该键与计算后的值关联起来；如果键已存在且值不为`null`，则直接返回已有的值**。

```java
V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)
```
- 参数：
    - `key`：要操作的键。
    - `mappingFunction`：一个函数，接收键作为输入，返回要关联到该键的值（若键不存在）。
- 返回值：与键关联的最终值（可能是已存在的值，也可能是新计算的值）。

最典型的场景是**当 Map 的值为集合类型（如`List`、`Set`）时，简化 “键不存在则初始化集合，再添加元素” 的逻辑**。