> **比赛场次**：
> **比赛题目**： [207. 课程表](https://leetcode.cn/problems/course-schedule/) 
## 题意：

你需要选修 numCourses 门课，但有些会有先修，你需要判断是否能够修完所有课程。
换句话说：给你一个有向图，判断图中是否有环

## 题解：

#middle #拓补排序 #图 #邻接表 #dfs #bfs #queue #队列 #判环

每个课程都有前置课程，我们一层一层学，考虑到这就是一个***拓补排序***，判断这个有向图***无环***：
1. 根据依赖关系，构建邻接表、入度数组。
2. 选取入度为 0 的数据，根据邻接表，减小依赖它的数据的入度。
3. 找出入度变为 0 的数据，重复第 2 步。
4. 直至所有数据的入度为 0，得到排序，如果还有数据的入度不为 0，说明图中存在环

除此之外，还可以使用dfs来进行判环，标记节点的3个不同状态，参考[灵神题解](https://leetcode.cn/problems/course-schedule/solutions/2992884/san-se-biao-ji-fa-pythonjavacgojsrust-by-pll7)


### 代码实现
#### 法一
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] inDegree = new int[numCourses]; // 入度数组，大小为numCourses即可
        ArrayList<Integer>[] graph = new ArrayList[numCourses]; // 邻接表，大小为numCourses
        // 初始化邻接表
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new ArrayList<>();
        }
        // 构建图：bi -> ai（ai依赖bi），ai的入度+1
        for (int[] prerequisite : prerequisites) {
            int ai = prerequisite[0];
            int bi = prerequisite[1];
            graph[bi].add(ai); // bi指向ai（ai依赖bi）
            inDegree[ai]++; // ai的入度+1
        }
        Queue<Integer> queue = new LinkedList<>();
        // 初始入队：入度为0的节点
        for (int i = 0; i < numCourses; i++) {
            if (inDegree[i] == 0) {
                queue.offer(i);
            }
        }
        int count = 0; // 记录拓扑排序中已处理的节点数
        while (!queue.isEmpty()) {
            int curr = queue.poll();
            count++;
            // 处理当前节点的所有邻接节点（依赖当前节点的节点）
            for (int next : graph[curr]) {
                inDegree[next]--;
                if (inDegree[next] == 0) {
                    queue.offer(next);
                }
            }
        }
        // 若所有节点都被处理，则无环，可完成所有课程
        return count == numCourses;
    }
}
```
> **时间复杂度：**$O(V+E)$ $V$ 指节点个数，$E$ 指边个数
> **空间复杂度：**$O(V+E)$ 

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] g = new ArrayList[numCourses];
        Arrays.setAll(g, i -> new ArrayList<>());
        for (int[] p : prerequisites) {
            g[p[1]].add(p[0]);
        }

        int[] colors = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            if (colors[i] == 0 && dfs(i, g, colors)) {
                return false; // 有环
            }
        }
        return true; // 没有环
    }

    // 返回 true 表示找到了环
    private boolean dfs(int x, List<Integer>[] g, int[] colors) {
        colors[x] = 1; // x 正在访问中
        for (int y : g[x]) {
            if (colors[y] == 1 || colors[y] == 0 && dfs(y, g, colors)) {
                return true; // 找到了环
            }
        }
        colors[x] = 2; // x 完全访问完毕，从 x 出发无法找到环
        return false; // 没有找到环
    }
}
```
> **时间复杂度：**$O(V+E)$ $V$ 指节点个数，$E$ 指边个数；每个节点至多递归访问一次，每条边至多遍历一次。
> **空间复杂度：**$O(V+E)$ 
## 其他
法一法二中，快速简易地构建邻接表使用了
```java
	ArrayList<Integer>[] graph = new ArrayList[numCourses]; // 邻接表，大小为numCourses
	// 初始化邻接表
	for (int i = 0; i < numCourses; i++) {
		graph[i] = new ArrayList<>();
	}
/////////////////////////////////////////////////////////////////////////
	List<Integer>[] g = new ArrayList[numCourses];
	Arrays.setAll(g, i -> new ArrayList<>());
```
这种方式类似Cpp中`vector<int> graph[n]`;当然也可嵌套List。这里指出一点值得注意的：`ArrayList<Integer>[] graph = new ArrayList[numCourses]`; 涉及到 Java 中**数组创建、泛型和对象初始化**的核心概念
关于Java的new的核心用法：
`new`关键字在 Java 中主要用于**分配内存并初始化对象**，但具体行为分为两种：
1. ***创建普通对象（调用构造器）***

这是最常见的用法：`new 类名(参数)`，会直接调用类的构造器，返回一个初始化完成的对象。
```java
// 调用ArrayList的无参构造器，创建一个ArrayList对象 
ArrayList<Integer> list = new ArrayList<Integer>();
```
这里`new ArrayList<Integer>()`会执行：

- 为`ArrayList`对象分配内存；
- 调用其构造器（这里是无参构造器）完成初始化（比如初始化内部数组）；
- 返回对象的引用，赋值给`list`。

2. ***创建数组（不直接调用构造器，而是初始化数组本身）***
数组在 Java 中是一种**特殊的对象**（不属于任何类，但继承自`Object`）。创建数组的语法是`new 元素类型[长度]`，它的行为和创建普通对象不同：

- 不调用任何 “数组类” 的构造器（因为数组没有显式的类定义）；
- 只为数组本身分配内存（存储元素的引用或值）；
- 自动初始化数组元素（引用类型默认`null`，基本类型默认 0/false 等）。
```java
// 创建一个能存储3个int的数组，元素默认值为0 
int[] intArr = new int[3]; 
// 创建一个能存储2个String的数组，元素默认值为null 
String[] strArr = new String[2];
```

我这种 `ArrayList<Integer>[] graph = new ArrayList[numCourses];` 写法是**创建 “存储泛型对象引用的数组”**，看起来奇怪的原因是 Java 对 “泛型数组” 有特殊限制。

1. 语法拆解
```java
// 声明：graph是一个数组，数组中的每个元素都是ArrayList<Integer>类型的引用
ArrayList<Integer>[] graph; 

// 初始化：创建一个长度为numCourses的数组，数组元素是ArrayList类型的引用（原始类型）
graph = new ArrayList[numCourses]; 
```

这里的关键是：**Java 不允许直接创建 “泛型类型的数组”**（比如`new ArrayList<Integer>[numCourses]`是编译错误），只能创建 “原始类型的数组”（`new ArrayList[numCourses]`），然后通过类型转换赋值给泛型数组引用（这里编译器会警告，但允许通过）。

2. 为什么不能直接创建`new ArrayList<Integer>[numCourses]`？

这是 Java 泛型的 “类型擦除” 机制导致的。

- 泛型在编译后会被擦除：`ArrayList<Integer>`编译后实际是`ArrayList`（原始类型）；
- 数组在运行时需要知道元素的具体类型（为了保证类型安全），但泛型擦除后，`ArrayList<Integer>`和`ArrayList<String>`在运行时无法区分；
- 因此，Java 禁止直接创建`new ArrayList<Integer>[numCourses]`，避免运行时类型判断出错。

所以只能用原始类型`new ArrayList[numCourses]`创建数组，再赋值给`ArrayList<Integer>[]`类型的引用（编译器会提示 “未检查的转换” 警告，但不影响运行）。

3. 数组元素的初始化

注意：`new ArrayList[numCourses]`只创建了**数组本身**，数组中的每个元素还是`null`（因为引用类型的默认值是`null`）。因此必须手动为每个元素创建`ArrayList`对象：
```java
ArrayList<Integer>[] graph = new ArrayList[numCourses];
// 必须逐个初始化数组中的元素，否则调用add()会报NullPointerException
for (int i = 0; i < numCourses; i++) {
    graph[i] = new ArrayList<Integer>(); // 这里才是调用ArrayList的构造器
}
```

这就像：
```java
String[] strArr = new String[2]; // strArr[0]和strArr[1]都是null
strArr[0] = new String("hello"); // 为第一个元素创建String对象
```