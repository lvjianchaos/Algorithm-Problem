**比赛场次 ** 星码StarryCoding 入门教育赛4

**比赛题目** C-这是啥数

<!--more-->

1 seconds / 256 megabytes

standard input / standard output

## 题目

给定一个由 𝑛 个元素组成的数组 𝑎 ，求数组在执行下列操作 **任意次** 后的最大和：

- 选择 **相邻** 的 2 个元素，翻转它们的符号。换句话说，选择一个下标 𝑖 (1≤𝑖≤𝑛−1) ，使 𝑎[𝑖]=−𝑎[𝑖] ，𝑎[𝑖+1]=−𝑎[𝑖+1] 。

## 输入

输入由多个测试用例组成。第一行包含一个整数 𝑇*T* (1≤𝑇≤1000) - 测试用例的数量。测试用例说明如下:

每个测试用例的第一行都包含一个整数 𝑛*n* (2≤𝑛≤2⋅1052≤*n*≤2⋅105) - 数组的长度。

下一行包含 𝑛*n* 个空格分隔的整数 𝑎1,𝑎2,…,𝑎𝑛 (−1e9≤𝑎𝑖≤1e9) 。

保证所有测试用例中 𝑛*n* 的总和不超过 2⋅1e5 。

## 输出

对于每个测试用例，输出数组在执行所述操作任意次数后可能具有的最大和。

## 样例

**输入**

> 5 
>
> 3 
>
> -1 -1 -1 
>
> 5 1 5 -5 0 2 
>
> 3 
>
> 1 2 3 
>
> 6 
>
> -1 10 9 8 7 6 
>
> 2 
>
> -1 -1

**输出**

> 1 
>
> 13 
>
> 6 
>
> 39 
>
> 2

## 解释

对于第一个测试用例，通过对前两个元素进行运算，我们可以将数组从 [−1,−1,−1] 变为 [1,1,−1] ，并且可以证明这个数组获得了最大可能的和，即 1+1+(−1)=1 。

在第二个测试案例中，通过对 −5 和 0 进行运算，我们将数组从 [1,5,−5,0,2] 变为 [1,5,−(−5),−0,2]=[1,5,5,0,2] ，由于所有元素都是非负数，所以这个数组的和是最大的。因此，答案是 1+5+5+0+2=13 。

对于第三个测试用例，数组已经只包含正数，因此无需进行运算。答案就是整个数组的和，即 1+2+3=6 。

## 题解

##### 【数学 思维】

##### **官方题解**

首先：

- 易证，无论进行多少次操作，负数个数的奇偶性都不会改变。因此，如果负数的个数最初是偶数，我们可以通过进行一些运算使负数的个数等于 0 。

因此：

- 如果负数的个数是 **偶数** ，答案就是所有数字的绝对值之和（因为我们可以把所有数字都变成正数）。
- 如果负数的个数是 **奇数** ，那么最后一定有一个负数。我们将选择绝对值最小的一个，其余的保持正数（为简单起见，我们将 0 视为负数）。

时间复杂度： 𝑂(𝑛)。

感想：

《首先》就没思考出来，负数个数的奇偶性不变，我该如何得到这个先决的结论呢？其实应该试着分类模拟一下(不妨将0看作负数)：

* 两个数都为正数，执行操作，负数个数`+2`
* 两个数都为负数，执行操作，负数个数`-2`
* 两数为一负一正，执行操作，负数个数`不变`

## 代码

##### 官方代码

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve()
{
    int n; cin >> n;
    vector<ll> a(n);
    for(auto &x : a) cin >> x;

    ll ans = 0, cnt = 0, mi = (1 << 31) - 1;
    for(auto &x : a)
    {
        if(x < 0)
        {
            cnt ++;
            x = -x;
        }
        ans += x;
        mi = min(mi, x);
    }

    cout << (cnt & 1 ? ans - 2 * mi : ans) << '\n';
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    int T; cin >> T;
    while(T --) solve();

    return 0;
}
```

