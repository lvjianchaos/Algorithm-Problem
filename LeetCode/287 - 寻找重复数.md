> **比赛场次**：
> **比赛题目**： [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

## 题意：
n + 1 个整数的数组 nums，数字范围 \[1,n\](包括1，n)，故而至少存在一个重复数。
假设只有一个，请你找出。$O(1)$ 空间复杂度，不修改数组。

## 题解：

#middle #数组 #快慢指针 #内向基环森林 #思维 

#### ~~法一~~
~~可知：共$n+1$个整数，有 2 个相同，也就是说，有 $1-n$ n个数字+其中之一的1个数字。~~
~~我们可以原地标记所有数字是否出现过——将对应数字下标的数字标为负数，若访问到负数，证明这个下标被访问了两次，也就是重复下标即重复数。~~
~~但这设计修改数组，故而不符合题意。~~
与之类似，原地哈希，每个数字安排到自己对应下标的位置，如果放不进去（已经有相同的数字了），则该数重复。
#### 法二
对 $i=0,1,2,…,n$，连一条从 $i$ 到 $nums[i]$ 的有向边，可以得到一个**有向图**
每个节点的入度，就是这个节点在 nums 中的出现次数。重复元素的入度大于 1。
在每个节点的出度都是 1 的情况下，n+1 个点 n+1 条边的有向图，又叫**内向基环森林**，每个连通块都恰好有一个环。
由于 $nums[i]≥1$，所以节点 0 的入度是 0，不在环上。从节点 0 出发，进入基环，基环的入环口，就是入度大于 1 的节点。
于是，可以用快慢指针查找环形链表。

> 假设，走到入环口 走a
> fast走了 2b，slow走了 b
> b = k·c
> b - a = slow在环走了几步
> 所以slow再走a步就了b也就是k·c, 回到入环口

### 代码实现
```java
// 法一：原地标记
class Solution {
    public int findDuplicate(int[] nums) {
        for(int num : nums) {
            int index = Math.abs(num);
            if(nums[index] < 0) return index;
            nums[index] = - nums[index];
        }
        return -1;
    }
}
```

```java
// 法二：环形链表
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0; // 0 一定不在环上，适合作为起点
        int fast = 0;
        while (true) {
            slow = nums[slow]; // 等价于 slow = slow.next
            fast = nums[nums[fast]]; // 等价于 fast = fast.next.next
            if (fast == slow) { // 快慢指针移动到同一个节点
                break;
            }
        }

        int head = 0; // 再用一个指针，从起点出发
        while (slow != head) {
            slow = nums[slow];
            head = nums[head];
        }
        return slow; // 入环口即重复元素
    }
}
```

> **时间复杂度：**$O(N)$
> **空间复杂度：**$O(1)$ 
## 其他
