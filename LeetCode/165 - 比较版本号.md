> **比赛场次**：
> **比赛题目**： [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/) 
## 题意：

给你由 "." 分隔的字符串，之间都是数字。你需要从左到右判断每一个数字是否相等，若var1>var2，返回1，var1\<var2，返回-1。若都匹配返回0。当然，忽略前导零，若有缺失看作0。
比如：1.001.032 与 1.01.32.1 => 返回 -1
将其看作 1，1，32，0 与 1，1，32，1
## 题解：

#字符串 #middle #双指针 #模拟

显而易见，我们可以使用**字符串分割函数**将每个数字分割出来，并**转换为数字**，再遍历进行比较，当然若有空缺看作0。
但这样需要额外的空间存储分割后的数字字符串。
为了减少空间复杂度，我们可以在自己分割字符串的过程计算每一段的数字，再进行比较，这样空间复杂度就$O(1)$

### 代码实现
```java
// 法一 - split函数
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] a = version1.split("\\.");
        String[] b = version2.split("\\.");
        int n = a.length;
        int m = b.length;
        for(int i = 0;i < n || i < m;i ++) {
            int ver1 = i < n ? Integer.parseInt(a[i]) : 0;
            int ver2 = i < m ? Integer.parseInt(b[i]) : 0;
            if(ver1 != ver2) {
                return ver1 < ver2 ? -1 : 1;
            }
        }
        return 0;
    }
}
```

> **时间复杂度：**$O(n+m)$ 
> **空间复杂度：**$O(n+m)$ 

```java
// 法二 - 双指针
class Solution {
    public int compareVersion(String version1, String version2) {
        int n = version1.length();
        int m = version2.length();
        int i = 0;
        int j = 0;
        while(i < n || j < m) {
            int var1 = 0;
            for(;i < n && version1.charAt(i) != '.';i ++) {
                var1 = var1 * 10 + version1.charAt(i) - '0';
            }
            i ++;
            int var2 = 0;
            for(;j < m && version2.charAt(j) != '.';j ++) {
                var2 = var2 * 10 + version2.charAt(j) - '0';
            }
            j ++;
            if(var1 != var2) {
                return var1 > var2 ? 1 : -1;
            }
        }
        return 0;
    }
}
```

> **时间复杂度：**$O(n+m)$
> **空间复杂度：**$O(1)$ 
## 其他
需要注意，Java中分割字符串中 **split()** 方法用于根据给定的 ***正则表达式*** 将字符串拆分为子字符串数组